#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"fsharp"},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!fsharp

#r "nuget: FsCheck"
#r "nuget:MathNet.Numerics"
#r "nuget:MathNet.Numerics.fsharp"

#!fsharp

[0..2..11]

#!fsharp

open MathNet.Numerics
open MathNet.Numerics.LinearAlgebra

#!fsharp

let a = Array2D.init 4 10  (fun i j -> float (i + j))

#!fsharp

let b = a |> DenseMatrix.ofArray2

#!fsharp

b.[0,0]

#!fsharp

b.SubMatrix(1,3,1,9)

#!fsharp

open FsCheck
open FsCheck.FSharp

#!fsharp

let g = Gen.choose (0, 100)
let g2 = Gen.choose (0, 100) |> Gen.map (fun x -> x * 2)

#!fsharp

let ab = Arb.fromGen g

#!fsharp

g2 |> Gen.sample 4

#!fsharp

type TestEnum =
    | First = 0

let testEnum (e:TestEnum) = e = TestEnum.First
Check.Quick testEnum

#!fsharp

type FormatResGenerators =
    static member FormatResInput() : Arbitrary<(int * (string * obj)[])> =
        let genPrintableString = 
            // Arb.generate<string> 
            ArbMap.defaults
            |> ArbMap.generate<string>
            |> Gen.map (fun s -> 
                let chars = 
                    s.ToCharArray() 
                    |> Array.filter (fun c -> System.Char.IsAsciiLetterOrDigit c || System.Char.IsWhiteSpace c) 
                    |> Array.filter ( fun c -> not <| System.Char.IsControl c)
                new string(chars |> Array.truncate 20)) // Keep strings reasonably short 
            |> Gen.filter (fun s -> not (String.IsNullOrWhiteSpace s )) // non-whitespace 

        // Generator for the object part of the data tuples
        let genObjValue =
             Gen.oneof [
                 ArbMap.defaults |> ArbMap.generate<int> |> Gen.map box
                 ArbMap.defaults |> ArbMap.generate<float> |> Gen.map box
                 genPrintableString |> Gen.map box // Re-use string generator for values
                 ArbMap.defaults |> ArbMap.generate<bool> |> Gen.map box
             ]

        // Generator for a single (string * obj) data entry
        let genDataEntry = Gen.map2 (fun k v -> (k, v)) genPrintableString genObjValue

        // Generator for the array of (string * obj)
        let genDataArray = 
            Gen.nonEmptyListOf genDataEntry 
            |> Gen.map List.toArray
            |> Gen.resize 5
            // |> Gen.sequenceToArray// Keep data arrays relatively small (0 to 5 elements)
    // Module to hold custom FsCheck generators for formatRes

    // Generator for the tuple (format_code, data_array)
    // This generator ensures that if format_code > 0, it's a valid 1-based index for the generated data_array.
        let generator =
            genDataArray
            |> Gen.bind( fun dataArr -> 
                let validIndices = [ -1; 0 ] @ (if Array.length dataArr > 0 then [ 1 .. Array.length dataArr ] else [])
                Gen.elements validIndices
                |> Gen.map (fun fmt -> (fmt, dataArr))
            )
        Arb.fromGen generator

#!fsharp

type MatrixGenerators =
    static member NiceMatrix() : Arbitrary<float[,]> =
        let genFiniteFloat = 
            ArbMap.defaults 
            |> ArbMap.arbitrary<NormalFloat> 
            |> Arb.convert NormalFloat float
            |> Arb.generate<float> 
            // |> Gen.map (fun x -> if System.Double.IsFinite x then x else 0.0)

        let genMatrix: Gen<float[,]> =
            Gen.sized (fun size ->
                // Ensure dimensions are at least 1, and scale with FsCheck's size parameter
                let s = max 1 (size % 4 + 1) // Dimensions from 1 to 4 for reasonable test times
                Gen.map2 (fun rows cols -> Array2D.init rows cols (fun _ _ -> Gen.sample 1 genFiniteFloat |> Seq.head))
                    (Gen.choose (1, s))
                    (Gen.choose (1, s)))
        genMatrix |> Arb.fromGen

#!fsharp

let array2DDoublesEqualWithTolerance (precision: int) (expected: float[,]) (actual: float[,]) : bool =
    if Array2D.length1 expected <> Array2D.length1 actual || Array2D.length2 expected <> Array2D.length2 actual then
        // printfn "Array dimensions differ. Expected (%d,%d), Actual (%d,%d)" (Array2D.length1 expected) (Array2D.length2 expected) (Array2D.length1 actual) (Array2D.length2 actual)
        false
    else
        let mutable isEqual = true
        // Define a sample 2D array
        let flattenArray (arr: 'a[,]) : 'a[] =
            arr |> Seq.cast<'a> |> Seq.toArray

        // Perform the conversion
        let e1d = flattenArray expected
        let a1d = flattenArray actual
        let tolerance = System.Math.Pow(10.0, -float precision) // Calculate tolerance
        Array.forall2 (fun e a -> abs (e - a) <= tolerance) e1d a1d

#!fsharp

MatrixGenerators.NiceMatrix().Generator
|> Gen.sample 10
|> Array.map( fun m -> printfn "%A" m; m)
|> Array.iter (fun m -> 
    let svd = ( m |> DenseMatrix.ofArray2 ).Svd()
    printfn "SVD: %A" svd
    printfn "U: %A" svd.U
    printfn "S: %A" svd.S
    printfn "V: %A" svd.VT)

#!fsharp

let x = [[33.98008291; -44.03071605; -38.20637293]
         [30.99657108; -1.797693135; 23.86798604]]

#!fsharp

x |> matrix |> (fun m -> 
    let svd = m.Svd()
    printfn "SVD: %A" svd
    printfn "U: %A" svd.U
    printfn "S: %A" svd.S
    printfn "V: %A" svd.VT)

#!fsharp

FormatResGenerators.FormatResInput().Generator 
|> Gen.sample 10 
|> Seq.iter (fun (fmt, data) -> 
    printfn "Format Code: %d" fmt
    data |> Array.iter (fun (k, v) -> printfn "  Key: %s, Value: %A" k v)
)

#!fsharp

"ä»–".ToCharArray() |> Array.iter (fun c -> 
    printfn "%A" <| System.Char.IsAsciiLetterOrDigit( c )
)

#!fsharp

let keyisnotempty (a:(int*(string*obj)[])) =
    let (fmt, data) = a
    let keys = 
        Array.tryFind (fun (k, v) -> (String.IsNullOrWhiteSpace k)) data
    keys.IsNone

#!fsharp

//with the custom generator, the test will pass

Check.One(Config.Quick.WithArbitrary([typeof<FormatResGenerators>]), keyisnotempty)

#!fsharp

//with default config, the test will fail
Check.Quick(keyisnotempty)

#!fsharp

//replay some case the investigate. use of property attributes
Check.One( Config.Quick.WithReplay(9606483055554133962UL,11636943459687056285UL), keyisnotempty)
